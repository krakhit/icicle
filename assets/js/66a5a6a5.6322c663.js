"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8902],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>m});var o=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=o.createContext({}),s=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=s(e.components);return o.createElement(c.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(t),g=a,m=u["".concat(c,".").concat(g)]||u[g]||d[g]||i;return t?o.createElement(m,r(r({ref:n},p),{},{components:t})):o.createElement(m,r({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=g;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[u]="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=t[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}g.displayName="MDXCreateElement"},8006:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var o=t(8168),a=(t(6540),t(5680));t(1873);const i={},r="Vector Operations API",l={unversionedId:"icicle/primitives/vec_ops",id:"icicle/primitives/vec_ops",title:"Vector Operations API",description:"Overview",source:"@site/docs/icicle/primitives/vec_ops.md",sourceDirName:"icicle/primitives",slug:"/icicle/primitives/vec_ops",permalink:"/icicle/primitives/vec_ops",editUrl:"https://github.com/ingonyama-zk/icicle/tree/main/docs/icicle/primitives/vec_ops.md",tags:[],version:"current",lastUpdatedBy:"Otsar",lastUpdatedAt:1725431562,formattedLastUpdatedAt:"9/4/2024",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"NTT - Number Theoretic Transform",permalink:"/icicle/primitives/ntt"},next:{title:"Polynomial API Overview",permalink:"/icicle/polynomials/overview"}},c={},s=[{value:"Overview",id:"overview",level:2},{value:"VecOpsConfig",id:"vecopsconfig",level:3},{value:"Fields",id:"fields",level:4},{value:"Default Configuration",id:"default-configuration",level:4},{value:"Element-wise Operations",id:"element-wise-operations",level:3},{value:"<code>vector_add</code>",id:"vector_add",level:4},{value:"<code>vector_sub</code>",id:"vector_sub",level:4},{value:"<code>vector_mul</code>",id:"vector_mul",level:4},{value:"<code>vector_div</code>",id:"vector_div",level:4},{value:"<code>vector_accumulate</code>",id:"vector_accumulate",level:4},{value:"<code>convert_montogomery</code>",id:"convert_montogomery",level:4},{value:"Scalar-Vector Operations",id:"scalar-vector-operations",level:3},{value:"<code>scalar_add_vec / scalar_sub_vec</code>",id:"scalar_add_vec--scalar_sub_vec",level:4},{value:"<code>scalar_sub_vec</code>",id:"scalar_sub_vec",level:4},{value:"<code>scalar_mul_vec</code>",id:"scalar_mul_vec",level:4},{value:"Matrix Operations",id:"matrix-operations",level:3},{value:"<code>matrix_transpose</code>",id:"matrix_transpose",level:4},{value:"Miscellaneous Operations",id:"miscellaneous-operations",level:3},{value:"<code>bit_reverse</code>",id:"bit_reverse",level:4},{value:"<code>slice</code>",id:"slice",level:4},{value:"<code>highest_non_zero_idx</code>",id:"highest_non_zero_idx",level:4},{value:"<code>polynomial_eval</code>",id:"polynomial_eval",level:4},{value:"<code>polynomial_division</code>",id:"polynomial_division",level:4},{value:"Rust and Go bindings",id:"rust-and-go-bindings",level:3}],p={toc:s},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.yg)(u,(0,o.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"vector-operations-api"},"Vector Operations API"),(0,a.yg)("h2",{id:"overview"},"Overview"),(0,a.yg)("p",null,"The Vector Operations API in Icicle provides a set of functions for performing element-wise and scalar-vector operations on vectors, matrix operations, and miscellaneous operations like bit-reversal and slicing. These operations can be performed on the host or device, with support for asynchronous execution."),(0,a.yg)("h3",{id:"vecopsconfig"},"VecOpsConfig"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"VecOpsConfig")," struct is a configuration object used to specify parameters for vector operations."),(0,a.yg)("h4",{id:"fields"},"Fields"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"stream: icicleStreamHandle")),": Specifies the CUDA stream for asynchronous execution. If ",(0,a.yg)("inlineCode",{parentName:"li"},"nullptr"),", the default stream is used."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_a_on_device: bool")),": Indicates whether the first input vector (",(0,a.yg)("inlineCode",{parentName:"li"},"a"),") is already on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the vector will be copied from the host to the device."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_b_on_device: bool")),": Indicates whether the second input vector (",(0,a.yg)("inlineCode",{parentName:"li"},"b"),") is already on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the vector will be copied from the host to the device. This field is optional."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_result_on_device: bool")),": Indicates whether the result should be stored on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the result will be transferred back to the host."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_async: bool")),": Specifies whether the vector operation should be performed asynchronously. When ",(0,a.yg)("inlineCode",{parentName:"li"},"true"),", the operation will not block the CPU, allowing other operations to proceed concurrently. Asynchronous execution requires careful synchronization to ensure data integrity."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"ext: ConfigExtension*")),": Backend-specific extensions.")),(0,a.yg)("h4",{id:"default-configuration"},"Default Configuration"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static VecOpsConfig default_vec_ops_config() {\n    VecOpsConfig config = {\n      nullptr, // stream\n      false,   // is_a_on_device\n      false,   // is_b_on_device\n      false,   // is_result_on_device\n      false,   // is_async\n    };\n    return config;\n}\n")),(0,a.yg)("h3",{id:"element-wise-operations"},"Element-wise Operations"),(0,a.yg)("p",null,"These functions perform element-wise operations on two input vectors ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"b"),", producing an output vector."),(0,a.yg)("h4",{id:"vector_add"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_add")),(0,a.yg)("p",null,"Adds two vectors element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_add(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_sub"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_sub")),(0,a.yg)("p",null,"Subtracts vector ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," from vector ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_sub(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_mul"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_mul")),(0,a.yg)("p",null,"Multiplies two vectors element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_mul(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_div"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_div")),(0,a.yg)("p",null,"Divides vector ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," by vector ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_div(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_accumulate"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_accumulate")),(0,a.yg)("p",null,"Adds vector b to a, inplace."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_accumulate(T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config);\n")),(0,a.yg)("h4",{id:"convert_montogomery"},(0,a.yg)("inlineCode",{parentName:"h4"},"convert_montogomery")),(0,a.yg)("p",null,"Convert a vector of field elements to/from montgomery form."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError convert_montgomery(const T* input, uint64_t size, bool is_into, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h3",{id:"scalar-vector-operations"},"Scalar-Vector Operations"),(0,a.yg)("p",null,"These functions apply a scalar operation to each element of a vector."),(0,a.yg)("h4",{id:"scalar_add_vec--scalar_sub_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_add_vec / scalar_sub_vec")),(0,a.yg)("p",null,"Adds a scalar to each element of a vector."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_add_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"scalar_sub_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_sub_vec")),(0,a.yg)("p",null,"Subtract each element of a vector from a scalar ",(0,a.yg)("inlineCode",{parentName:"p"},"scalar-vec"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_sub_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"scalar_mul_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_mul_vec")),(0,a.yg)("p",null,"Multiplies each element of a vector by a scalar."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_mul_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h3",{id:"matrix-operations"},"Matrix Operations"),(0,a.yg)("p",null,"These functions perform operations on matrices."),(0,a.yg)("h4",{id:"matrix_transpose"},(0,a.yg)("inlineCode",{parentName:"h4"},"matrix_transpose")),(0,a.yg)("p",null,"Transposes a matrix."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError matrix_transpose(const T* mat_in, uint32_t nof_rows, uint32_t nof_cols, const VecOpsConfig& config, T* mat_out);\n")),(0,a.yg)("h3",{id:"miscellaneous-operations"},"Miscellaneous Operations"),(0,a.yg)("h4",{id:"bit_reverse"},(0,a.yg)("inlineCode",{parentName:"h4"},"bit_reverse")),(0,a.yg)("p",null,"Reorders the vector elements based on a bit-reversal pattern."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError bit_reverse(const T* vec_in, uint64_t size, const VecOpsConfig& config, T* vec_out);\n")),(0,a.yg)("h4",{id:"slice"},(0,a.yg)("inlineCode",{parentName:"h4"},"slice")),(0,a.yg)("p",null,"Extracts a slice from a vector."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError slice(const T* vec_in, uint64_t offset, uint64_t stride, uint64_t size, const VecOpsConfig& config, T* vec_out);\n")),(0,a.yg)("h4",{id:"highest_non_zero_idx"},(0,a.yg)("inlineCode",{parentName:"h4"},"highest_non_zero_idx")),(0,a.yg)("p",null,"Finds the highest non-zero index in a vector."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError highest_non_zero_idx(const T* vec_in, uint64_t size, const VecOpsConfig& config, int64_t* out_idx);\n")),(0,a.yg)("h4",{id:"polynomial_eval"},(0,a.yg)("inlineCode",{parentName:"h4"},"polynomial_eval")),(0,a.yg)("p",null,"Evaluates a polynomial at given domain points."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError polynomial_eval(const T* coeffs, uint64_t coeffs_size, const T* domain, uint64_t domain_size, const VecOpsConfig& config, T* evals /*OUT*/);\n")),(0,a.yg)("h4",{id:"polynomial_division"},(0,a.yg)("inlineCode",{parentName:"h4"},"polynomial_division")),(0,a.yg)("p",null,"Divides two polynomials."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError polynomial_division(const T* numerator, int64_t numerator_deg, const T* denumerator, int64_t denumerator_deg, const VecOpsConfig& config, T* q_out /*OUT*/, uint64_t q_size, T* r_out /*OUT*/, uint64_t r_size);\n")),(0,a.yg)("h3",{id:"rust-and-go-bindings"},"Rust and Go bindings"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/icicle/golang-bindings/vec-ops"},"Golang")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/icicle/rust-bindings/vec-ops"},"Rust"))))}d.isMDXComponent=!0},1873:(e,n,t)=>{t(6540)}}]);