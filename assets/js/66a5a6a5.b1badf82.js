"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8902],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>m});var o=n(6540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),s=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=s(n),g=a,m=u["".concat(l,".").concat(g)]||u[g]||d[g]||r;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=g;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[u]="string"==typeof e?e:a,i[1]=c;for(var s=2;s<r;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},8006:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var o=n(8168),a=(n(6540),n(5680));n(1873);const r={},i="Vector Operations API",c={unversionedId:"icicle/primitives/vec_ops",id:"icicle/primitives/vec_ops",title:"Vector Operations API",description:"Overview",source:"@site/docs/icicle/primitives/vec_ops.md",sourceDirName:"icicle/primitives",slug:"/icicle/primitives/vec_ops",permalink:"/icicle/primitives/vec_ops",editUrl:"https://github.com/ingonyama-zk/icicle/tree/main/docs/docs/icicle/primitives/vec_ops.md",tags:[],version:"current",lastUpdatedBy:"Karthik Inbasekar",lastUpdatedAt:1731500995,formattedLastUpdatedAt:"11/13/2024",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"NTT - Number Theoretic Transform",permalink:"/icicle/primitives/ntt"},next:{title:"Polynomial API Overview",permalink:"/icicle/polynomials/overview"}},l={},s=[{value:"Overview",id:"overview",level:2},{value:"VecOpsConfig",id:"vecopsconfig",level:3},{value:"Fields",id:"fields",level:4},{value:"Default Configuration",id:"default-configuration",level:4},{value:"Element-wise Operations",id:"element-wise-operations",level:3},{value:"<code>vector_add</code>",id:"vector_add",level:4},{value:"<code>vector_sub</code>",id:"vector_sub",level:4},{value:"<code>vector_mul</code>",id:"vector_mul",level:4},{value:"<code>vector_div</code>",id:"vector_div",level:4},{value:"<code>vector_accumulate</code>",id:"vector_accumulate",level:4},{value:"<code>convert_montogomery</code>",id:"convert_montogomery",level:4},{value:"Reduction operations",id:"reduction-operations",level:3},{value:"<code>vector_sum</code>",id:"vector_sum",level:4},{value:"<code>vector_product</code>",id:"vector_product",level:4},{value:"Scalar-Vector Operations",id:"scalar-vector-operations",level:3},{value:"<code>scalar_add_vec / scalar_sub_vec</code>",id:"scalar_add_vec--scalar_sub_vec",level:4},{value:"<code>scalar_sub_vec</code>",id:"scalar_sub_vec",level:4},{value:"<code>scalar_mul_vec</code>",id:"scalar_mul_vec",level:4},{value:"Matrix Operations",id:"matrix-operations",level:3},{value:"<code>matrix_transpose</code>",id:"matrix_transpose",level:4},{value:"Miscellaneous Operations",id:"miscellaneous-operations",level:3},{value:"<code>bit_reverse</code>",id:"bit_reverse",level:4},{value:"<code>slice</code>",id:"slice",level:4},{value:"<code>highest_non_zero_idx</code>",id:"highest_non_zero_idx",level:4},{value:"<code>polynomial_eval</code>",id:"polynomial_eval",level:4},{value:"<code>polynomial_division</code>",id:"polynomial_division",level:4},{value:"Rust and Go bindings",id:"rust-and-go-bindings",level:3}],p={toc:s},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,o.A)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"vector-operations-api"},"Vector Operations API"),(0,a.yg)("h2",{id:"overview"},"Overview"),(0,a.yg)("p",null,"The Vector Operations API in Icicle provides a set of functions for performing element-wise and scalar-vector operations on vectors, matrix operations, and miscellaneous operations like bit-reversal and slicing. These operations can be performed on the host or device, with support for asynchronous execution."),(0,a.yg)("h3",{id:"vecopsconfig"},"VecOpsConfig"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"VecOpsConfig")," struct is a configuration object used to specify parameters for vector operations."),(0,a.yg)("h4",{id:"fields"},"Fields"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"stream: icicleStreamHandle")),": Specifies the CUDA stream for asynchronous execution. If ",(0,a.yg)("inlineCode",{parentName:"li"},"nullptr"),", the default stream is used."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_a_on_device: bool")),": Indicates whether the first input vector (",(0,a.yg)("inlineCode",{parentName:"li"},"a"),") is already on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the vector will be copied from the host to the device."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_b_on_device: bool")),": Indicates whether the second input vector (",(0,a.yg)("inlineCode",{parentName:"li"},"b"),") is already on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the vector will be copied from the host to the device. This field is optional."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_result_on_device: bool")),": Indicates whether the result should be stored on the device. If ",(0,a.yg)("inlineCode",{parentName:"li"},"false"),", the result will be transferred back to the host."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"is_async: bool")),": Specifies whether the vector operation should be performed asynchronously. When ",(0,a.yg)("inlineCode",{parentName:"li"},"true"),", the operation will not block the CPU, allowing other operations to proceed concurrently. Asynchronous execution requires careful synchronization to ensure data integrity."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"batch_size: int")),": Number of vectors (or operations) to process in a batch. Each vector operation will be performed independently on each batch element."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"columns_batch: bool")),": True if the batched vectors are stored as columns in a 2D array (i.e., the vectors are strided in memory as columns of a matrix). If false, the batched vectors are stored contiguously in memory (e.g., as rows or in a flat array)."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},(0,a.yg)("inlineCode",{parentName:"strong"},"ext: ConfigExtension*")),": Backend-specific extensions.")),(0,a.yg)("h4",{id:"default-configuration"},"Default Configuration"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"static VecOpsConfig default_vec_ops_config() {\n    VecOpsConfig config = {\n      nullptr, // stream\n      false,   // is_a_on_device\n      false,   // is_b_on_device\n      false,   // is_result_on_device\n      false,   // is_async\n      1,       // batch_size\n      false,   // columns_batch\n      nullptr  // ext\n    };\n    return config;\n}\n")),(0,a.yg)("h3",{id:"element-wise-operations"},"Element-wise Operations"),(0,a.yg)("p",null,"These functions perform element-wise operations on two input vectors a and b. If VecOpsConfig specifies a batch_size greater than one, the operations are performed on multiple pairs of vectors simultaneously, producing corresponding output vectors."),(0,a.yg)("h4",{id:"vector_add"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_add")),(0,a.yg)("p",null,"Adds two vectors element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_add(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_sub"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_sub")),(0,a.yg)("p",null,"Subtracts vector ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," from vector ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_sub(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_mul"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_mul")),(0,a.yg)("p",null,"Multiplies two vectors element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_mul(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_div"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_div")),(0,a.yg)("p",null,"Divides vector ",(0,a.yg)("inlineCode",{parentName:"p"},"a")," by vector ",(0,a.yg)("inlineCode",{parentName:"p"},"b")," element-wise."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_div(const T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_accumulate"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_accumulate")),(0,a.yg)("p",null,"Adds vector b to a, inplace."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_accumulate(T* vec_a, const T* vec_b, uint64_t size, const VecOpsConfig& config);\n")),(0,a.yg)("h4",{id:"convert_montogomery"},(0,a.yg)("inlineCode",{parentName:"h4"},"convert_montogomery")),(0,a.yg)("p",null,"Convert a vector of field elements to/from montgomery form."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError convert_montgomery(const T* input, uint64_t size, bool is_into, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h3",{id:"reduction-operations"},"Reduction operations"),(0,a.yg)("p",null,"These functions perform reduction operations on vectors. If VecOpsConfig specifies a batch_size greater than one, the operations are performed on multiple vectors simultaneously, producing corresponding output values. The storage arrangement of batched vectors is determined by the columns_batch field in the VecOpsConfig."),(0,a.yg)("h4",{id:"vector_sum"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_sum")),(0,a.yg)("p",null,"Computes the sum of all elements in each vector in a batch."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_sum(const T* vec_a, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"vector_product"},(0,a.yg)("inlineCode",{parentName:"h4"},"vector_product")),(0,a.yg)("p",null,"Computes the product of all elements in each vector in a batch."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError vector_product(const T* vec_a, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h3",{id:"scalar-vector-operations"},"Scalar-Vector Operations"),(0,a.yg)("p",null,"These functions apply a scalar operation to each element of a vector. If VecOpsConfig specifies a batch_size greater than one, the operations are performed on multiple vector-scalar pairs simultaneously, producing corresponding output vectors."),(0,a.yg)("h4",{id:"scalar_add_vec--scalar_sub_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_add_vec / scalar_sub_vec")),(0,a.yg)("p",null,"Adds a scalar to each element of a vector."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_add_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"scalar_sub_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_sub_vec")),(0,a.yg)("p",null,"Subtract each element of a vector from a scalar ",(0,a.yg)("inlineCode",{parentName:"p"},"scalar-vec"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_sub_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h4",{id:"scalar_mul_vec"},(0,a.yg)("inlineCode",{parentName:"h4"},"scalar_mul_vec")),(0,a.yg)("p",null,"Multiplies each element of a vector by a scalar."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError scalar_mul_vec(const T* scalar_a, const T* vec_b, uint64_t size, const VecOpsConfig& config, T* output);\n")),(0,a.yg)("h3",{id:"matrix-operations"},"Matrix Operations"),(0,a.yg)("p",null,"These functions perform operations on matrices. If VecOpsConfig specifies a batch_size greater than one, the operations are performed on multiple matrices simultaneously, producing corresponding output matrices."),(0,a.yg)("h4",{id:"matrix_transpose"},(0,a.yg)("inlineCode",{parentName:"h4"},"matrix_transpose")),(0,a.yg)("p",null,"Transposes a matrix."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError matrix_transpose(const T* mat_in, uint32_t nof_rows, uint32_t nof_cols, const VecOpsConfig& config, T* mat_out);\n")),(0,a.yg)("h3",{id:"miscellaneous-operations"},"Miscellaneous Operations"),(0,a.yg)("h4",{id:"bit_reverse"},(0,a.yg)("inlineCode",{parentName:"h4"},"bit_reverse")),(0,a.yg)("p",null,"Reorders the vector elements based on a bit-reversal pattern. If VecOpsConfig specifies a batch_size greater than one, the operation is performed on multiple vectors simultaneously."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError bit_reverse(const T* vec_in, uint64_t size, const VecOpsConfig& config, T* vec_out);\n")),(0,a.yg)("h4",{id:"slice"},(0,a.yg)("inlineCode",{parentName:"h4"},"slice")),(0,a.yg)("p",null,"Extracts a slice from a vector. If VecOpsConfig specifies a batch_size greater than one, the operation is performed on multiple vectors simultaneously, producing corresponding output vectors."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError slice(const T* vec_in, uint64_t offset, uint64_t stride, uint64_t size_in, uint64_t size_out, const VecOpsConfig& config, T* vec_out);\n")),(0,a.yg)("h4",{id:"highest_non_zero_idx"},(0,a.yg)("inlineCode",{parentName:"h4"},"highest_non_zero_idx")),(0,a.yg)("p",null,"Finds the highest non-zero index in a vector. If VecOpsConfig specifies a batch_size greater than one, the operation is performed on multiple vectors simultaneously."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError highest_non_zero_idx(const T* vec_in, uint64_t size, const VecOpsConfig& config, int64_t* out_idx);\n")),(0,a.yg)("h4",{id:"polynomial_eval"},(0,a.yg)("inlineCode",{parentName:"h4"},"polynomial_eval")),(0,a.yg)("p",null,"Evaluates a polynomial at given domain points. If VecOpsConfig specifies a batch_size greater than one, the operation is performed on multiple vectors simultaneously."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError polynomial_eval(const T* coeffs, uint64_t coeffs_size, const T* domain, uint64_t domain_size, const VecOpsConfig& config, T* evals /*OUT*/);\n")),(0,a.yg)("h4",{id:"polynomial_division"},(0,a.yg)("inlineCode",{parentName:"h4"},"polynomial_division")),(0,a.yg)("p",null,"Divides two polynomials. If VecOpsConfig specifies a batch_size greater than one, the operation is performed on multiple vectors simultaneously."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\neIcicleError polynomial_division(const T* numerator, int64_t numerator_deg, const T* denumerator, int64_t denumerator_deg, const VecOpsConfig& config, T* q_out /*OUT*/, uint64_t q_size, T* r_out /*OUT*/, uint64_t r_size);\n")),(0,a.yg)("h3",{id:"rust-and-go-bindings"},"Rust and Go bindings"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/icicle/golang-bindings/vec-ops"},"Golang")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/icicle/rust-bindings/vec-ops"},"Rust"))))}d.isMDXComponent=!0},1873:(e,t,n)=>{n(6540)}}]);