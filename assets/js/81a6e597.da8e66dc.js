"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8213],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>g});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,s=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),h=l(t),d=i,g=h["".concat(c,".").concat(d)]||h[d]||p[d]||s;return t?a.createElement(g,r(r({ref:n},u),{},{components:t})):a.createElement(g,r({ref:n},u))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var s=t.length,r=new Array(s);r[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[h]="string"==typeof e?e:i,r[1]=o;for(var l=2;l<s;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=t(8168),i=(t(6540),t(5680));t(1873);const s={},r="ICICLE Hashing in Rust",o={unversionedId:"icicle/rust-bindings/hash",id:"icicle/rust-bindings/hash",title:"ICICLE Hashing in Rust",description:"For a general overview of ICICLE's hashing logic and supported algorithms, check out the ICICLE Hashing Overview.",source:"@site/docs/icicle/rust-bindings/hash.md",sourceDirName:"icicle/rust-bindings",slug:"/icicle/rust-bindings/hash",permalink:"/icicle/rust-bindings/hash",editUrl:"https://github.com/ingonyama-zk/icicle/tree/main/docs/docs/icicle/rust-bindings/hash.md",tags:[],version:"current",lastUpdatedBy:"Karthik Inbasekar",lastUpdatedAt:1731500995,formattedLastUpdatedAt:"11/13/2024",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"Rust FFI Bindings for Univariate Polynomial",permalink:"/icicle/rust-bindings/polynomials"},next:{title:"Merkle Tree API Documentation (Rust)",permalink:"/icicle/rust-bindings/merkle"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Importing Hash Functions",id:"importing-hash-functions",level:2},{value:"API Usage",id:"api-usage",level:2},{value:"1. Creating a Hasher Instance",id:"1-creating-a-hasher-instance",level:3},{value:"2. Hashing a Simple String",id:"2-hashing-a-simple-string",level:3},{value:"3. Poseidon Example (field elements) and batch hashing",id:"3-poseidon-example-field-elements-and-batch-hashing",level:3}],u={toc:l},h="wrapper";function p(e){let{components:n,...t}=e;return(0,i.yg)(h,(0,a.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"icicle-hashing-in-rust"},"ICICLE Hashing in Rust"),(0,i.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.yg)("div",{parentName:"div",className:"admonition-heading"},(0,i.yg)("h5",{parentName:"div"},(0,i.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,i.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.yg)("div",{parentName:"div",className:"admonition-content"},(0,i.yg)("p",{parentName:"div"},"For a general overview of ICICLE's hashing logic and supported algorithms, check out the ",(0,i.yg)("a",{parentName:"p",href:"/icicle/primitives/hash"},"ICICLE Hashing Overview"),"."))),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,"The ICICLE library provides Rust bindings for hashing using a variety of cryptographic hash functions. These hash functions are optimized for both general-purpose data and cryptographic operations such as multi-scalar multiplication, commitment generation, and Merkle tree construction."),(0,i.yg)("p",null,"This guide will show you how to use the ICICLE hashing API in Rust with examples for common hash algorithms, such as Keccak-256, Keccak-512, SHA3-256, SHA3-512, Blake2s, and Poseidon."),(0,i.yg)("h2",{id:"importing-hash-functions"},"Importing Hash Functions"),(0,i.yg)("p",null,"To use the hashing functions in Rust, you will need to import the specific hash algorithm module from the ICICLE Rust bindings. For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_hash::keccak::Keccak256;\nuse icicle_hash::keccak::Keccak512;\nuse icicle_hash::sha3::Sha3_256;\nuse icicle_hash::sha3::Sha3_512;\nuse icicle_hash::blake2s::Blake2s;\nuse icicle_core::poseidon::Poseidon;\n")),(0,i.yg)("h2",{id:"api-usage"},"API Usage"),(0,i.yg)("h3",{id:"1-creating-a-hasher-instance"},"1. Creating a Hasher Instance"),(0,i.yg)("p",null,"Each hash algorithm can be instantiated by calling its respective constructor. The new function takes an optional default input size, which can be set to 0 unless required for a specific use case."),(0,i.yg)("p",null,"Example for Keccak-256:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"let keccak_hasher = Keccak256::new(0 /* default input size */).unwrap();\n")),(0,i.yg)("h3",{id:"2-hashing-a-simple-string"},"2. Hashing a Simple String"),(0,i.yg)("p",null,"Once you have created a hasher instance, you can hash any input data, such as strings or byte arrays, and store the result in an output buffer.\nHere\u2019s how to hash a simple string using Keccak-256:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},'use icicle_hash::keccak::Keccak256;\nuse icicle_runtime::memory::HostSlice;\nuse icicle_core::hash::HashConfig;\nuse hex;\n\nlet input_str = "I like ICICLE! it\'s so fast and easy";\nlet mut output = vec![0u8; 32]; // 32-byte output buffer\n\nlet keccak_hasher = Keccak256::new(0 /* default input size */).unwrap();\nkeccak_hasher\n    .hash(\n        HostSlice::from_slice(input_str.as_bytes()),  // Input data\n        &HashConfig::default(),                       // Default configuration\n        HostSlice::from_mut_slice(&mut output),       // Output buffer\n    )\n    .unwrap();\n\n// convert the output to a hex string for easy readability\nlet output_as_hex_str = hex::encode(output);\nprintln!("Hash(`{}`) = {:?}", input_str, &output_as_hex_str);\n\n')),(0,i.yg)("h3",{id:"3-poseidon-example-field-elements-and-batch-hashing"},"3. Poseidon Example (field elements) and batch hashing"),(0,i.yg)("p",null,"The Poseidon hash is designed for cryptographic field elements and curves, making it ideal for use cases such as zero-knowledge proofs (ZKPs).\nPoseidon hash using babybear field:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-rust"},"use icicle_babybear::field::{ScalarCfg, ScalarField};\nuse icicle_core::hash::HashConfig;\nuse icicle_core::poseidon::{Poseidon, PoseidonHasher};\nuse icicle_core::traits::FieldImpl;\nuse icicle_runtime::memory::HostSlice;\n\nlet batch = 1 << 10; // Number of hashes to compute in a single batch\nlet t = 3; // Poseidon parameter that specifies the arity (number of inputs) for each hash function\nlet mut outputs = vec![ScalarField::zero(); batch]; // Output array sized for the batch count\n\n// Case (1): Hashing without a domain tag\n// Generates 'batch * t' random input elements as each hash needs 't' inputs\nlet inputs = ScalarCfg::generate_random(batch * t);\nlet poseidon_hasher = Poseidon::new::<ScalarField>(t as u32, None /*=domain-tag*/).unwrap(); // Instantiate Poseidon without domain tag\n\nposeidon_hasher\n    .hash(\n        HostSlice::from_slice(&inputs),           // Input slice for the hash function\n        &HashConfig::default(),                   // Default hashing configuration\n        HostSlice::from_mut_slice(&mut outputs),  // Output slice to store hash results\n    )\n    .unwrap();\n\n// Case (2): Hashing with a domain tag\n// Generates 'batch * (t - 1)' inputs, as domain tag counts as one input in each hash\nlet inputs = ScalarCfg::generate_random(batch * (t - 1));\nlet domain_tag = ScalarField::zero(); // Example domain tag (can be any valid field element)\nlet poseidon_hasher_with_domain_tag = Poseidon::new::<ScalarField>(t as u32, Some(&domain_tag) /*=domain-tag*/).unwrap();\n\nposeidon_hasher_with_domain_tag\n    .hash(\n        HostSlice::from_slice(&inputs),           // Input slice with 't - 1' elements per hash\n        &HashConfig::default(),                   // Default hashing configuration\n        HostSlice::from_mut_slice(&mut outputs),  // Output slice to store hash results\n    )\n    .unwrap();\n")))}p.isMDXComponent=!0},1873:(e,n,t)=>{t(6540)}}]);